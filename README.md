<H2>INFORME</H2>
<p align="center"><img src="img/logo.png"/></p>
<H3>1. PLANTEAMIENTO DEL PROBLEMA</H3>
<p align="justify">La programación orientada a objetos consigue innovar la forma de obtener los resultados, donde ellos son los encargados de manejar los datos de entrada para poder obtener los datos de salida necesarios, siendo cada objeto portador de una función especial que se le asigno.</p>

<p align="justify">Varios de los códigos que posee POO permitira la adquisición de librerías para el cumplimiento de varias funciones necesarias, los cuales nos acortan realizar un algoritmo para ellos, con solo digitar este comando.</p>

<p align="justify">GPIO, siendo la parte física en un chip lo cual toma el nombre de “pin”, es capaz de ser controlado por el usuario, en tiempo de ejecución, si es presentado de manera física.</p>

<p align="justify">Dando la facilidad, GPIO, tiene su propia librería para realizar una simulación de los pines que se pueden usar en su tabla, con tanto solo realizar la importación mediante el lenguaje de programación Python, podemos obtener los pines y hacerlos trabajar tal cual de manera física, controlándolo mediante funciones.</p>

<H3>2. OBJETIVOS</H3>
<b>Objetivos Generales</b>
<p align="justify">- Realizar un video explicando e identificando lo aprendido sobre lenguajes de programación.</p>
<p align="justify">- Conocer los beneficios de usar GPIO, POO, Python.</p>
<b>Objetivos Específicos</b>
<p align="justify">- Emplear los comandos que nos brinda POO, para cumplir nuestro problema.</p>
<p align="justify">- Analizar la plataforma https://create.withcode.uk/ para la ejecución de nuestra aplicación.</p>

<H3>3. ESTADO DEL ARTE</H3>
<b>Implementación del protocolo de control de servicios de invernadero mediante Python en Raspberry PI</b><br>
<p align="justify">La tecnología de las TIC se aplica ampliamente a diversas industrias, incluida la agricultura. En el sector agrícola, la mayoría de los dispositivos e invernaderos siguen utilizando tecnologías de comunicación serial muy antiguas. Hoy en día, muchas tecnologías TIC como ZigBee, Bluetooth e Internet se están extendiendo pero aún no son interoperables. En Corea se está elaborando un conjunto de normas para garantizar la interoperabilidad entre diferentes proveedores. En particular, la interoperabilidad básica se puede proporcionar mediante la estandarización del protocolo LCP independiente de la infraestructura de red subyacente. En este artículo, diseñamos el protocolo de control de servicio basado en el protocolo LCP y lo implementamos mediante Python.<br><br></p>
<p align="justify">- Fuente: Implementation of greenhouse service control protocol using Python on Raspberry PI - IEEE Conference Publication. (n.d.). Recuperado en Septiembre 8, 2020, de https://ieeexplore.ieee.org/document/8701890</p>

<b>Automatización inteligente del hogar con un sistema de monitoreo de puertas único para personas mayores que utilizan Python, OpenCV, Android y Raspberry pi</b>
<p align="justify">En este artículo, sistema inteligente de domótica particularmente para las personas de la vejez se propone basado en python, OpenCV, raspberry pi y aplicación Android. Los aparatos son controlados por el servidor Raspberry pi, que funciona de acuerdo con el comando de usuario (toque o voz) recibido desde el teléfono móvil. Un sistema único de monitoreo de puertas, el cual está diseñado, basado en la detección de rostros y el reconocimiento de una cámara instalada fuera de la puerta principal, a la que se puede acceder desde el teléfono mediante la aplicación Android. Una característica interesante que se ha añadido es que, todos los aparatos también se pueden controlar a través de la voz del usuario. Para la eficiencia energética el usuario puede analizar el uso de cada dispositivo desde su teléfono. Además, el usuario también puede controlar la intensidad de la luz, así como la velocidad del ventilador. Con todas estas características incorporadas en un solo sistema con una interfaz de usuario buena y sencilla, este sistema es rentable y perfecto para las personas de la vejez que viven solas en sus casas.<br><br></p>
<p align="justify">- Fuente: Jivani, M. N. (2014). GSM Based Home Automation System Using App-Inventor for Android Mobile Phone. International Journal of Advanced Research in Electrical, Electronics and Instrumentation Engineering, 03(09), 12121–12128. https://doi.org/10.15662/ijareeie.2014.0309042</p>

<b>Uso de las computadoras Raspberry Pi en la educación</b>
<p align="justify">Este artículo describe las ideas de usar computadoras Raspberry Pi en escuelas secundarias y educación superior. Raspberry Pi es un potente ordenador en un tamaño de tarjeta de crédito. Fue creado por la organización benéfica Raspberry Pi Foundation, cuyo objetivo principal era la reintroducción del aprendizaje de habilidades informáticas entre los estudiantes. El sistema operativo Raspbian se basa en Linux y ofrece un excelente entorno de trabajo para los estudiantes, ya que incluye soluciones de software diseñadas para ampliar el conocimiento de los estudiantes de ciencias de la computación de una manera interesante. Además de los conocimientos de informática, también es adecuado para adquirir conocimientos básicos en electrónica. También es muy importante tener la posibilidad de interconectar dichos conocimientos adquiridos. Nuestros estudiantes han adoptado el conocimiento sobre cómo instalar y utilizar el sistema operativo Raspbian, cómo conectarse en red y conectarse a Internet, cómo escribir programas utilizando el lenguaje de programación Python y cómo desarrollar proyectos basados en hardware. A partir de nuestra propia experiencia en Raspberry Pi podemos concluir que esta es una plataforma ideal para que los estudiantes adquieran nuevos conocimientos y competencias en el campo de la informática y la electrónica.<br></p>
<p align="justify">- Fuente: Donat, W. (2014). Learn Raspberry Pi Programming with Python. In Learn Raspberry Pi Programming with Python. Apress. https://doi.org/10.1007/978-1-4302-6425-5</p>

<H3>4. MARCO TEORICO</H3>
<p align="justify">La programación Orientada a objetos se define como un paradigma de la programación, una manera de programar específica, donde se organiza el código en unidades denominadas clases, de las cuales se crean objetos que se relacionan entre sí para conseguir los objetivos de las aplicaciones.</p>

<p align="justify">Es una forma especial de programar, más cercana a como expresaríamos las cosas en la vida real que otros tipos de programación.</p>

<p align="justify">Al programar orientado a objetos tenemos que aprender a pensar cómo resolver los problemas de una manera distinta a como se realizaba anteriormente, en la programación estructurada. Ahora tendremos que escribir nuestros programas en términos de clases, objetos, propiedades, métodos y otras cosas que veremos rápidamente para aclarar conceptos y dar una pequeña base que permita soltarnos un poco con los conceptos de este tipo de programación.</p>

<H3>4.1 PROPIEDADES EN CLASES</H3>
<p align="justify">Las propiedades o atributos son las características de los objetos. Cuando definimos una propiedad normalmente especificamos su nombre y su tipo. Nos podemos hacer a la idea de que las propiedades son algo así como variables donde almacenamos datos relacionados con los objetos.</p>

<H3>4.2 MÉTODOS EN LAS CLASES</H3>
<p align="justify">Son las funcionalidades asociadas a los objetos. Cuando estamos programando las clases las llamamos métodos. Los métodos son como funciones que están asociadas a un objeto.</p>

<H3>4.3 MENSAJES EN OBJETOS</H3>
<p align="justify">Un mensaje en un objeto es la acción de efectuar una llamada a un método. Por ejemplo, cuando le decimos a un objeto coche que se ponga en marcha estamos pasándole el mensaje "ponte en marcha".</p>

<p align="justify">Para mandar mensajes a los objetos utilizamos el operador punto, seguido del método que deseamos invocar y los paréntesis, como en las llamadas a las funciones.</p>

<p align="center"><b>miAuto.ponteEnMarcha()</b></p>

<p align="justify">En este ejemplo pasamos el mensaje "ponteEnMarcha" al objeto "miAuto". Hay que colocar paréntesis igual que cualquier llamada a una función, dentro irían los parámetros, si es que el método los requiere.</p>

<H3>4.4 GPIO</H3>
<p align="justify">Los periféricos GPIO varían muy ampliamente. En algunos casos son, simplemente, un grupo de pines que se puede cambiar en grupo ya sea de entrada o de salida. En otros, cada pin puede configurarse con flexibilidad para aceptar o entregar diferentes voltajes lógicos, y con la potencia de accionamiento configurables y tire ups / bajadas . Las tensiones de entrada y salida son típicamente la tensión de alimentación del dispositivo que contiene los GPIO, y pueden ser dañados por mayores tensiones. Algunos GPIO tienen entradas tolerantes de 5 V: incluso cuando el dispositivo tiene una tensión de alimentación baja (por ejemplo, 2 V), el dispositivo puede aceptar 5 V sin daño.</p>

<H3>4.5 CAPACIDAD GPIO</H3>
<p align="justify">Para mandar mensajes a los objetos utilizamos el operador punto, seguido del método que deseamos invocar y los paréntesis, como en las llamadas a las funciones.</p>

<li>•	Pines GPIO que pueden ser configurados para ser entrada o salida.</li>
<li>•	Pines GPIO que pueden ser activados / desactivados.</li>
<li>•	valores de entrada se pueden leer (por lo general alto = 1, bajo = 0)</li>
<li>•	valores de salida de lectura / escritura.</li>
<li>•	valores de entrada que a menudo se pueden utilizar como IRQ (típicamente para los eventos de activación)</li>
<li>•	el dispositivo puede utilizar DMA para mover grandes cantidades de datos de manera eficiente dentro o fuera del dispositivo.</li>


<H3>5. DIAGRAMAS</H3>
<p align="center"><img src="img/diagrama1.png"/></p>
<p align="center"><img src="img/diagrama2.png"/></p>

<H3>6. LISTA DE COMPONENTES</H3>
<p align="justify"><b>Raspberry pi</b></p>
CPU + GPU: Broadcom BCM2837B0, Cortex-A53 (ARMv8) 64-bit SoC @ 1.4GHz</p>
RAM: 1GB LPDDR2 SDRAM</p>
Wi-Fi + Bluetooth: 2.4GHz y 5GHz IEEE 802.11.b/g/n/ac, Bluetooth 4.2, BLE</p>
Ethernet: Gigabit Ethernet sobre USB 2.0 (300 Mbps)</p>
GPIO de 40 pines</p>
HDMI</p>
4 puertos USB 2.0</p>
Puerto CSI para conectar una cámara.</p></p></p>
Puerto DSI para conectar una pantalla táctil</p></p>
Salida de audio estéreo y vídeo compuesto</p>
Micro-SD</p>
Power-over-Ethernet (PoE)</p>
<p align="center"><img src="img/pi.jpg"/></p>
<p align="justify"><b>Python</b></p>
Python es un lenguaje de programación interpretado cuya filosofía hace hincapié en la legibilidad de su código. Se trata de un lenguaje de programación multiparadigma, ya que soporta orientación a objetos, programación imperativa y, en menor medida, programación funcional. Es un lenguaje interpretado, dinámico y multiplataforma.(Documentation, 2020)</p>
Es administrado por la Python Software Foundation. Posee una licencia de código abierto, denominada Python Software Foundation License,</p>
<H3>7. MAPA DE VARIABLES</H3>
<p align="center"><img src="img/variable1.png"/></p>
<H3>8. EXPLICACION DEL CODIGO FUENTE</H3>
<b><p align="justify">Alarma de incendios.</p></b>
import RPi.GPIO as GPIO</p>
import time</p>

GPIO.setmode(GPIO.BOARD)</p>
GPIO.setup(40, GPIO.OUT)</p>

class Alarma:</p>
  i=0</p></p>
  gass=0</p>
  h=0</p>
  tema=0</p>
  temb=0</p>
  
  def menu(self):</p>
    print("\nIndicaciones")</p>
    print("8) Sensor de gas")</p>
    print("10) Sensor de humo")</p>
    print("12) Temperatura 45")</p>
    print("11) Temperatura 60")</p>
  
  def gas(self):</p>
    gass=0</p>
    if GPIO.input(8) == GPIO.HIGH:</p>
      gass=1</p>
    return gass</p>
  def humo(self):</p>
    h=0</p>
    if GPIO.input(10) == GPIO.HIGH:</p>
      h=1</p>
    return h</p>
  def tem45(self):</p>
    tema=0</p>
    if GPIO.input(12) == GPIO.HIGH:</p>
      tema=1</p>
    return tema</p>
  def tem60(self):</p>
    temb=0</p>
    if GPIO.input(11) == GPIO.HIGH:</p>
      temb=1</p>
    return temb</p>
  def incendio(self,gass,h,tema,temb):</p>
    i = temb + gass*tema + gass*h + tema*h</p>
    return i</p>
  
  def imprimir(self,a):</p>
    print("\n\nSE INENDIA, AUXILIO¡¡")</p>
    print("\n\nApagar Alarma pin 37")</p>
    print("Primero desactive los anteriores pins")</p>
   
  def foco(self):</p>
    while (GPIO.input(37) != GPIO.HIGH):</p></p>
      GPIO.output(40, True)</p>
      time.sleep(0.5)</p>
      GPIO.output(40, False)</p>
      time.sleep(0.5)</p>
     
t=1  </p>  

alam=Alarma()</p>
alam.menu()</p>
while (t!=0):</p>
  gas=alam.gas()</p>
  humo=alam.humo()</p>
  tem45=alam.tem45()</p>
  tem60=alam.tem60()</p>
  si=alam.incendio(gas,humo,tem45,tem60)</p>
  if si >= 1:</p>
    alam.imprimir(si)</p>
    
Se importa la libreia RPi.GPIO as GPIO y la libreria time</p>.Se programa la tarjeta raspberry pi y se pone al pin o puerto GPIO #40 como nuestro puerto de salida luego se define la clase Alarma la cual tiene 5 atributos "i" como incendio, gass como el sensor de gas, h como el sensor de humo, tema como temperatura de 45, temb como temperatura de 60.</p>Se define la funcion menu en donde se encuentran las indicaciones de nuestro programa.</p>Se define la funcion gas:tiene una variable gass esta se activa a travez del GPIO #8,se define la funcion hunmo:tiene la variable h y se activa con el GPIO #10,se define la funcion tem45:tiene una variable tema la cual se activa con el GPIO #12,se define la funcion tem60:tiene una variable temb la cual se activa con el GPIO #11,se define la variable incendio la mas indispensable ya que su variable incluye a todas sus demas variables para poder saber si se activa o no la alarma de incendio.</p>Se define la variable imprimir la cual nos servira para enviar un mensaje que nos demuetre si se esta incendiando o no y nos muestra indicaciones para poder apagar a alarma.</p>Se define la variable foco el cual esta en nuestro GPIO de salida #40,en esta funcion se describe uma repeticion mientras el GPIO #37 no este presionado pues el GPIO #40 se prendera es deir el foco se prendera y ademas utilizamos time para simular la luz de una alarma.</p>En nuestro principal llamamos a todas las funciones, bjetos, atributos, metodos que tengamos y utilizamos un repetir para poder utilizar el programa las veces que queramos .

<b><p align="justify">Sistema de riego.</p></b>
# Importacion Librerias
import RPi.GPIO as GPIO</p>
import time</p>

GPIO.setmode(GPIO.BOARD)</p>
GPIO.setup(3, GPIO.IN)</p>
GPIO.setup(5, GPIO.IN)</p>
GPIO.setup(7, GPIO.IN)</p>
GPIO.setup(8, GPIO.IN)</p>
GPIO.setup(15, GPIO.OUT)</p>

# Clase
class bombaDeAgua:</p>

# Declarar funciones  
  def menu(self):</p>
    print(" SISTEMA DE RIEGO ")</p>
    print(" PIN 3) Deposito de Agua (Marcado=Vacio) (Desmarcado=Lleno) ")</p>
    print(" PIN 5) Epoca Verano (Marcado=Verano) (Desmarcado=Restante del año) ")</p>
    print(" PIN 7) Dia/Noche (Marcado=Dia) (Desmarcado=Noche) ")</p>
    print(" PIN 8) Tierra (Marcado=Seca) (Desmarcado=Humeda) ")</p>
    print("\nSelecciones un pin:")</p>
    def leer(self,mensaje):</p>
        print(mensaje)</p>
    men1=float(input())</p>
    return men1</p>
  
  def estadosCircuito(self):</p>
        V = GPIO.input(3) # Deposito de agua</p>
        S = GPIO.input(8) # Tipo de Tierra</p>
        D = GPIO.input(7) # Dia/Noche</p>
        R = GPIO.input(5) # Restricciones, verano.</p>
        
        if (V == GPIO.HIGH): # Deposito de agua vacio
            GPIO.output(15, GPIO.LOW)
            print("No podra trabajar la bomba de agua, ya que su deposito de agua esta vacio")
            time.sleep(0.3)
        elif (V == GPIO.LOW and R == GPIO.HIGH and D == GPIO.LOW):
            GPIO.output(15, GPIO.HIGH)
            print("Bomba encendida")
            time.sleep(0.3)
        elif ((V == GPIO.LOW and R == GPIO.LOW and S == GPIO.HIGH and D == GPIO.HIGH) or (V == GPIO.LOW and R == GPIO.LOW and S == GPIO.HIGH and D == GPIO.LOW)):
            GPIO.output(15, GPIO.HIGH)
            print("Bomba encendida")
            time.sleep(0.3)
        else:
            GPIO.output(15, GPIO.LOW)
            print("No selecciono ninguna opcion valida")
            time.sleep(0.3)

            GPIO.cleanup()</p>

# Instanciar / Crear nuevo objeto / Llamar</p>
b = bombaDeAgua()</p>
b.menu()</p>
b.estadosCircuito()</p>

Se importa la libreia RPi.GPIO as GPIO y la libreria time.</p>Se programa la tarjeta raspberry pi y se pone al pin o puerto GPIO #3,5,7,8 como mis puertos de entrada, y se pone al GPIO #15 como nuestro puerto de salida.</p>Se define la clase bomba de agua.</p>Se define la funcion menu en el cual nos da indicaciones de como funciona nuestro sistema de riego.</p>Se define la funcion estadosCircuito en la cual a nuestras variables se les asignan respectivamente un puerto:V=GPIO #3(deposito de agua),S=GPIO #8(tipo de tierra),D=GPIO #7(Dia/Noche),R=GPIO #5(Restricciones,verano).</p>Se realiza una condicion para determinar si el deposito de agua esta vacio o sin la bomba de agua esta ensendida y tambien para determinar que no se selecciono una opcion valida.</p>Por ultimo se crea un objeto b y se llama a las fucniones menu y estadosCircuito. 

<H3>9. DESCRIPCION DE PRERREQUISITOS Y CONFIGURACION</H3>
<p align="justify">Se necesita conocimiento en programacion otientada a objetos en python al igual que un buen conocimineto y manipulacion de librerias para la realizacion del ejercicio</p>

<H3>10. APORTACIONES</H3>
<b>Programacion orientada a objetos </b>
<p align="justify">Es un paradigma de programación que viene a innovar la forma de obtener resultados. Los objetos manipulan los datos de entrada para la obtención de datos de salida específicos, donde cada objeto ofrece una funcionalidad especial.</p>
Muchos de los objetos prediseñados de los lenguajes de programación actuales permiten la agrupación en bibliotecas o librerías, sin embargo, muchos de estos lenguajes permiten al usuario la creación de sus propias bibliotecas.</p>
Está basada en varias técnicas del sexenio: herencia, cohesión, abstracción, polimorfismo, acoplamiento y encapsulamiento.</p>
Su uso se popularizó a principios de la década de 1990. En la actualidad, existe una gran variedad de lenguajes de programación que soportan la orientación a objetos.(Coad, P; Yourdon, E. (1991))</p>
<b>GPIO</b>
<p align="justify">Es un pin genérico en un chip, cuyo comportamiento (incluyendo si es un pin de entrada o salida) se puede controlar (programar) por el usuario en tiempo de ejecución.
Los pines GPIO no tienen ningún propósito especial definido, y no se utilizan de forma predeterminada. La idea es que a veces, para el diseño de un sistema completo que utiliza el chip podría ser útil contar con un puñado de líneas digitales de control adicionales, y tenerlas a disposición ahorra el tiempo de tener que organizar circuitos adicionales para proporcionarlos. Por ejemplo, los chips Realtek ALC260 (códec de audio) tienen 8 pines GPIO, que quedan sin utilizar de forma predeterminada. Algunos integradores de sistemas (Acer Inc. laptops) que emplea el ALC260 utilizan la primera GPIO (GPIO0) para encender el amplificador utilizado para los altavoces internos y el conector de auriculares del ordenador portátil.(Merino, 2019)</p>
<p align="justify">Edge TPU complementa las CPU, GPU y FPGA, además de otras soluciones ASIC, a fin de ejecutar la IA en el perímetro.</p>
<b>E/S datos</b></p>
Para que un programa pueda ejecutar las tareas para las que fue creado es necesario que se pueda comunicar con los usuarios para capturar la información y presentar los resultados. También debe poder almacenar y recuperar información de dispositivos de almacenamiento permanente para preservarla ya que el contenido de las variables se pierde una vez que la ejecución del programa termina. El contenido de los dispositivos de almacenamiento permanente se organiza en unidades llamadas archivos que los programas abren para poder leer o escribir información. El mecanismo para interactuar con un usuario se llama interfaz de usuario y puede ser gráfica o de texto.</p>
<H3>11. CONCLUSIONES</H3>
<p align="justify">Realizada la investigación sobre los puertos de entrada y salida en la Raspberry Pi  y además de la realización de los ejercicios propuestos se llegó a las siguientes conclusiones:<br><br>
-Mediante la investigación y la implementación de los ejercicios planteados se logró observar el manejo y la nuevas maneras de realizar el ingreso y salida de datos por los puertos GPIO<br></p>

-Los simuladores de entrada y salida de datos para la  Raspberry Pi tienen con base el uso de los puertos GPIO mediante los cuales pueden mandar y recibir impulsos eléctricos los cuales nos ayudan a generar  programas de manera funcional.<br></p>

-Se implementó de manera exitosa los ejercicios planteados  cada uno con su respectiva simulación<br></p>

-Para el desarrollo exitoso de los ejemplos se realizó el uso de varios sensores, los cuales nos permitirán ingresar los valores por los puertos GPIO<br></p>

Después de haber logrado los objetivos específicos se llegó a la conclusión que gracias a estos objetivos específicos se lograra llegar a la implementación y la realización de los objetivos generales.<br></p>

-Los puertos GPIO presentes en la Raspberry Pi tienen diferentes características entre las cueles encontramos el no tener protección a las cargas eléctricas recibidas además de estar enumerados por su posición físicas o también pueden estar enumerados por la posición de un chip.<br></p>

-Se logró conocer diferentes maneras de implementar la programación orientada a objetos con el ingreso y salida de datos por los puertos GPIO y gracias a esto se pudo implementar de manera exitosa los ejercicios planteados.<br></p>


<H3>12. RECOMENDACIONES</H3>
<p align="justify">-Durante el estudio de esta asignatura se mostró que los temas presentados en clase son solo el comienzo de lo que es la materia gracias a lo cual se puede aumentar el conocimiento  adquirido en el semestre.<br><br>
-Conocer las diferentes formas en las cuales se puede hacer el ingreso y la salida de datos atreves de los puertos GPIO y mostrar la salida de la información mediante controladores o diferentes tipos de hardware adicional.<br><br>
-Conocer los distintos tipos de paradigmas de programación que existen y en especial en los lenguajes de programación que son más utilizados en la actualidad.<br></p>

<H3>13. CRONOGRAMA</H3>
<p align="center"><img src="img/cronograma (2).jpeg"/></p>

<H3>14. BIBLIOGRAFIA</H3>
<p align="justify">-	JORGE CACHO HERNÁNDEZ, «Raspberry Pi: tutoriales Servidor web, ownCloud y XBMC.,» 27 Enero 2008. [En línea]. Available: file:///C:/Users/home/Downloads/102190284-Raspberry-Pi-tutoriales-servidor-web-ownCloud-y-XBMC.pdf<br><br>
-	C. Muñoz, «Historia de la informatica “Raspberry Pi,» Blog sobre Historia de la Informática, 18 Diciembre 2013. [En línea]. Available: https://histinf.blogs.upv.es/2013/12/18/raspberry-pi/#:~:text=Raspberry%20PI%20es%20una%20placa,de%20la%20inform%C3%A1tica%20en%20las<br><br>
- Maria Sol Vicet Illas, «Historia y defincion de software libre en el mundo e lainformatica inicial,» Ecured.cu, Ecuador, 2017 Available:https://www.ecured.cu/Software _libre#:~:text= Seg%C3%BAn%20la%20Free%20Software%20Foundation,programa%2C%20con%20cualquier%20prop%C3%B3sito%3B%20de<br><br>
- C. Muñoz, «Historia de la informatica “Raspberry Pi,» Blog sobre Historia de la Informática, 18 Diciembre 2013. [En línea]. Available: https://histinf.blogs.upv.es/2013/12/18/raspberry-pi/#:~:text=Raspberry%20PI%20es%20una%20placa,de%20la%20inform%C3%A1tica%20en%20las<br><br>
- Moya, F., 2020. Entradas Y Salidas Digitales · Taller De Raspberry Pi. [online] Franciscomoya.gitbooks.io. Available at: <https://franciscomoya.gitbooks.io/taller-de-raspberry-pi/content/es/elems/gpio.html> [Accessed 22 August 2020].<br><br>
-	Diec.unizar.es. 2020. [online] Available at: <http://diec.unizar.es /~tpollan/libro/Apuntes/ digap8.pdf> <br><br>
-	P-Accessed 22 August 2020].“Medir distancia con Arduino y sensor de ultrasonidos HC-SR04.” [Online]. Available: https://www.luisllamas.es/medir-distancia-con-arduino-y-sensor-de-ultrasonidos-hc-sr04/. [Accessed: 23-Jul-2020]. <br><br>
  Coad, P; Yourdon, E. (1991). Prentice-Hall International editions, ed. Object-oriented Design</p>
  Brookshear, J. Glenn (2012). Computer Science: An overview [Introducción a la computación] (11.ª edición). Madrid, España: Pearson Educación, S. A. p. 704.</p>
  Documentation, P. (18 de Agosto de 2020). python.org. Obtenido de Python : https://es.wikipedia.org/wiki/Python</p>
GPIO. (7 de Agosto de 2019). Obtenido de https://es.wikipedia.org/wiki/GPIO#:~:text=GPIO%20(General%20Purpose%20Input%2FOutput,usuario%20en%20tiempo%20de%20ejecuci%C3%B3n.</p>
-	“Medir inclinación con Arduino y sensor tilt SW- 520D.” [Online]. Available: https://www.luisllamas.es/medir-inclinacion-con-arduino-y-sensor-tilt-sw-520d/#:~:text=Un sensor de inclinación es,partir de una cierta inclinación. [Accessed: 23-Jul-2020].<br><br>
  
<H3>15. ANEXOS</H3>
<H3>15.1 MANUAL DE USUARIO</H3>
<p align="justify">Adjunto en la carpeta Manual de Usuario.</p>
<H3>15.2 HOJAS TECNICAS</H3>
<p align="justify">Adjunto en la carpeta Hojas Técnicas.</p>



